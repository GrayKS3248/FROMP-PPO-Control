#include "python_interface.hpp"

//******************************************************************** PYTHON API CONVERSION FUNCTIONS ********************************************************************//
/**
* Converts 1D vector<double> to a 1D PyList
* @param The vector used to create list
* @return PyObject pointer pointing at the created list
*/
template <typename T>
PyObject* get_1D_list(T arr)
{
	PyObject *list;
	
	list = PyList_New(arr.size());
	for (unsigned int i = 0; i < arr.size(); i++)
	{
		PyList_SetItem(list, i, PyFloat_FromDouble(arr[i]));
	}
	return list;
}

/**
* Converts 2D vector<vector<int>> to a 2D PyList
* @param The vector used to create list
* @return PyObject pointer pointing at the created list
*/
template <typename T>
PyObject* get_2D_list(T arr)
{
	PyObject *mat, *vec;

	mat = PyList_New(arr.size());
	for (unsigned int i = 0; i < arr.size(); i++)
	{
		vec = PyList_New(arr[0].size());
		for (unsigned int j = 0; j < arr[0].size(); j++)
		{
			PyList_SetItem(vec, j, PyFloat_FromDouble(arr[i][j]));
		}
		PyList_SetItem(mat, i, vec);
	}
	
	return mat;
}

/**
* Converts 3D object to a 3D PyList
* @param The vector used to create list
* @return PyObject pointer pointing at the created list
*/
template <typename T>
PyObject* get_3D_list(T arr)
{
	PyObject *ten, *mat, *vec;

	ten = PyList_New(arr.size());
	for(unsigned int i = 0; i < arr.size(); i++)
	{
		mat = PyList_New(arr[0].size());
		for (unsigned int j = 0; j < arr[0].size(); j++)
		{
			vec = PyList_New(arr[0][0].size());
			for (unsigned int k = 0; k < arr[0][0].size(); k++)
			{
				PyList_SetItem(vec, k, PyFloat_FromDouble(arr[i][j][k]));
			}
			PyList_SetItem(mat, j, vec);
		}
		PyList_SetItem(ten, i, mat);
	}
	
	return ten;
}

/**
* Converts PyList to a 1D vector<double>
* @param The list used to create the vector
* @return 1D vector<double> copy of the PyList
*/
vector<double> get_1D_vector(PyObject* list)
{
	if (PyList_Size(list) > 0)
	{
		vector<double> out(PyList_Size(list), 0.0);
		for (unsigned int i = 0; i < PyList_Size(list); i++)
		{
			out[i] = PyFloat_AsDouble(PyList_GetItem(list, i));
		}
		return out;
	}
	return vector<double>();
}

/**
* Converts PyList to a 2D vector<vector<double>>
* @param The list used to create the vector
* @return 2D vector<vector<double>> copy of the PyList
*/
vector<vector<double>> get_2D_vector(PyObject* list)
{
	if ((PyList_Size(list) > 0) && (PyList_Size(PyList_GetItem(list, 0)) > 0))
	{
		vector<vector<double>> out = vector<vector<double>>(PyList_Size(list), vector<double>(PyList_Size(PyList_GetItem(list, 0)), 0.0));
		
		for (unsigned int i = 0; i < PyList_Size(list); i++)
		for (unsigned int j = 0; j < PyList_Size(PyList_GetItem(list, i)); j++)
		{
			out[i][j] = PyFloat_AsDouble(PyList_GetItem(PyList_GetItem(list, i), j));
			
		}
		return out;
	}
	return vector<vector<double>>(1, vector<double>(1, 0.0));
}


//******************************************************************** PYTHON API INITIALIZATION FUNCTIONS ********************************************************************//
/**
* Initializes a PPO agent
* @param The number of additional inputs beyond the state image given to the agent during action generation
* @param The number of outputs generated by the actor (The number of inputs to the environment)
*/
PyObject* init_agent(int num_addtional_inputs, int num_outputs, string load_path_str)
{
	// Create configuration file handler
	Config_Handler agent_cfg = Config_Handler("../config_files", "trainer.cfg");
	long total_trajectories;
	agent_cfg.get_var("total_trajectories",total_trajectories);
	long steps_per_trajectory;
	agent_cfg.get_var("steps_per_trajectory",steps_per_trajectory);
	long trajectories_per_batch;
	agent_cfg.get_var("trajectories_per_batch",trajectories_per_batch);
	long epochs_per_batch;
	agent_cfg.get_var("epochs",epochs_per_batch);
	double gamma;
	agent_cfg.get_var("gamma",gamma);
	double lambda;
	agent_cfg.get_var("lambda",lambda);
	double epsilon;
	agent_cfg.get_var("epsilon",epsilon);
	double start_alpha;
	agent_cfg.get_var("start_alpha",start_alpha);
	double end_alpha;
	agent_cfg.get_var("end_alpha",end_alpha);
	const char* load_path = load_path_str.c_str();
	bool reset_std;
	agent_cfg.get_var("reset_stdev",reset_std);
	
	// Calculate decay rate
	double decay_rate = pow(end_alpha/start_alpha, (double)trajectories_per_batch/(double)total_trajectories);
	
	// Define module name
	PyObject* name = PyUnicode_DecodeFSDefault("PPO");

	// Initialize module
	PyObject* module = PyImport_Import(name);
	if (module == NULL)
	{
		fprintf(stderr, "\nFailed to find ppo module.\n");
		PyErr_Print();
		Py_DECREF(name);
		return NULL;
	}
	Py_DECREF(name);

	// Load dictionary of module methods and variables
	PyObject* dict = PyModule_GetDict(module);
	if (dict == NULL)
	{
		fprintf(stderr, "\nFailed to load ppo module dictionary.\n");
		PyErr_Print();
		Py_DECREF(module);
		return NULL;
	}
	Py_DECREF(module);

	// Get the initialization function from the module dictionary
	PyObject* init = PyDict_GetItemString(dict, "Agent");
	if (init == NULL || !PyCallable_Check(init))
	{
		fprintf(stderr, "\nFailed to find PPO Agent __init__ function.\n");
		PyErr_Print();
		Py_DECREF(dict);
		if (init != NULL) { Py_DECREF(init); }
		return NULL;
	}
	Py_DECREF(dict);

	// Build the initialization arguments

	PyObject* init_args = PyTuple_New(12);
	PyTuple_SetItem(init_args, 0, PyLong_FromLong(num_addtional_inputs));
	PyTuple_SetItem(init_args, 1, PyLong_FromLong(num_outputs));
	PyTuple_SetItem(init_args, 2, PyLong_FromLong(steps_per_trajectory));
	PyTuple_SetItem(init_args, 3, PyLong_FromLong(trajectories_per_batch));
	PyTuple_SetItem(init_args, 4, PyLong_FromLong(epochs_per_batch));
	PyTuple_SetItem(init_args, 5, PyFloat_FromDouble(gamma));
	PyTuple_SetItem(init_args, 6, PyFloat_FromDouble(lambda));
	PyTuple_SetItem(init_args, 7, PyFloat_FromDouble(epsilon));
	PyTuple_SetItem(init_args, 8, PyFloat_FromDouble(start_alpha));
	PyTuple_SetItem(init_args, 9, PyFloat_FromDouble(decay_rate));
	PyTuple_SetItem(init_args, 10, PyUnicode_DecodeFSDefault(load_path));
	if (reset_std)
	{
		PyTuple_SetItem(init_args, 11, Py_True);
	}
	else
	{
		PyTuple_SetItem(init_args, 11, Py_False);
	}

	// Initialize ppo object
	PyObject* object = PyObject_CallObject(init, init_args);
	if (object == NULL)
	{
		fprintf(stderr, "\nFailed to call agent __init__ function.\n");
		PyErr_Print();
		Py_DECREF(init);
		Py_DECREF(init_args);
		return NULL;
	}
	Py_DECREF(init);
	Py_DECREF(init_args);

	// return the class
	return object;
}

/**
* Initializes the save_render_plot class of the PPO module
* @return pyobject pointer to loaded class on success, NULL on failure
*/
PyObject* init_save_render_plot()
{
	// Define module name
	PyObject* name = PyUnicode_DecodeFSDefault("PPO");

	// Initialize module
	PyObject* module = PyImport_Import(name);
	if (module == NULL)
	{
		fprintf(stderr, "\nFailed to find PPO module:\n");
		PyErr_Print();
		Py_DECREF(name);
		return NULL;
	}
	Py_DECREF(name);

	// Load dictionary of module methods and variables
	PyObject* dict = PyModule_GetDict(module);
	if (dict == NULL)
	{
		fprintf(stderr, "\nFailed to load PPO module dictionary:\n");
		PyErr_Print();
		Py_DECREF(module);
		return NULL;
	}
	Py_DECREF(module);

	// Get the initialization function from the module dictionary
	PyObject* init = PyDict_GetItemString(dict, "Save_Plot_Render");
	if (init == NULL || !PyCallable_Check(init))
	{
		fprintf(stderr, "\nFailed to find Save_Plot_Render __init__ function:\n");
		PyErr_Print();
		Py_DECREF(dict);
		if (init != NULL) { Py_DECREF(init); }
		return NULL;
	}
	Py_DECREF(dict);

	// Initialize autoencoder object
	PyObject* object = PyObject_CallObject(init, NULL);
	if (object == NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render __init__ function:\n");
		PyErr_Print();
		Py_DECREF(init);
		return NULL;
	}
	Py_DECREF(init);
	
	// return the class
	return object;
}


//******************************************************************** PYTHON API CALL METHOD FUNCTIONS ********************************************************************//
/**
* Stores training curves to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param vector containing the actor reward curve
* @param vector containing the critic learning curve
* @return 0 on success, 1 on failure
*/
int store_training_curves(PyObject* save_render_plot, vector<double> r_per_episode, vector<double> value_error)
{
	// Convert inputs
	PyObject* py_r_per_episode = get_1D_list<vector<double>>(r_per_episode);
	PyObject* py_value_error = get_1D_list<vector<double>>(value_error);
	
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_training_curves", "(O,O)", py_r_per_episode, py_value_error);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_training_curves function:\n");
		PyErr_Print();
		Py_DECREF(py_r_per_episode);
		Py_DECREF(py_value_error);
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	Py_DECREF(py_r_per_episode);
	Py_DECREF(py_value_error);
	return 0;
}

/**
* Stores learning rate curves to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param vector containing the actor lr curve
* @param vector containing the critic lr curve
* @return 0 on success, 1 on failure
*/
int store_lr_curves(PyObject* save_render_plot, vector<double> actor_lr, vector<double> critic_lr)
{
	// Convert inputs
	PyObject* py_actor_lr = get_1D_list<vector<double>>(actor_lr);
	PyObject* py_critic_lr = get_1D_list<vector<double>>(critic_lr);
	
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_lr_curves", "(O,O)", py_actor_lr, py_critic_lr);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_lr_curves function:\n");
		PyErr_Print();
		Py_DECREF(py_actor_lr);
		Py_DECREF(py_critic_lr);
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	Py_DECREF(py_actor_lr);
	Py_DECREF(py_critic_lr);
	return 0;
}

/**
* Stores stdev history to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param vector containing x rate stdev data
* @param vector containing y rate stdev data
* @param vector containing magnitude stdev data
* @return 0 on success, 1 on failure
*/
int store_stdev_history(PyObject* save_render_plot, vector<double> x_stdev, vector<double> y_stdev, vector<double> mag_stdev)
{
	// Convert inputs
	PyObject* py_x_loc_stdev = get_1D_list<vector<double>>(x_stdev);
	PyObject* py_y_loc_stdev = get_1D_list<vector<double>>(y_stdev);
	PyObject* py_mag_stdev = get_1D_list<vector<double>>(mag_stdev);
	
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_stdev_history", "(O,O,O)", py_x_loc_stdev, py_y_loc_stdev, py_mag_stdev);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_stdev_history function:\n");
		PyErr_Print();
		Py_DECREF(py_x_loc_stdev);
		Py_DECREF(py_y_loc_stdev);
		Py_DECREF(py_mag_stdev);
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	Py_DECREF(py_x_loc_stdev);
	Py_DECREF(py_y_loc_stdev);
	Py_DECREF(py_mag_stdev);
	return 0;
}

/**
* Stores input history to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param vector containing input x location history
* @param vector containing input y location history
* @param vector containing input magnitude percent history
* @param vector containing trigger power history
* @param vector containing source power history
* @return 0 on success, 1 on failure
*/
int store_input_history(PyObject* save_render_plot, vector<double> input_location_x, vector<double> input_location_y, vector<double> input_percent, vector<double> trigger_power, vector<double> source_power)
{
	// Convert inputs
	PyObject* py_input_location_x = get_1D_list<vector<double>>(input_location_x);
	PyObject* py_input_location_y = get_1D_list<vector<double>>(input_location_y);
	PyObject* py_input_percent = get_1D_list<vector<double>>(input_percent);
	PyObject* py_trigger_power = get_1D_list<vector<double>>(trigger_power);
	PyObject* py_source_power = get_1D_list<vector<double>>(source_power);
	
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_input_history", "(O,O,O,O,O)", py_input_location_x, py_input_location_y, py_input_percent, py_trigger_power, py_source_power);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_input_history function:\n");
		PyErr_Print();
		Py_DECREF(py_input_location_x);
		Py_DECREF(py_input_location_y);
		Py_DECREF(py_input_percent);
		Py_DECREF(py_trigger_power);
		Py_DECREF(py_source_power);
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	Py_DECREF(py_input_location_x);
	Py_DECREF(py_input_location_y);
	Py_DECREF(py_input_percent);
	Py_DECREF(py_trigger_power);
	Py_DECREF(py_source_power);
	return 0;
}

/**
* Stores field history to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param vector containing temperature field history
* @param vector containing cure field history
* @return 0 on success, 1 on failure
*/
int store_field_history(PyObject* save_render_plot, vector<vector<vector<double>>> temperature_field, vector<vector<vector<double>>> cure_field, 
vector<vector<vector<double>>> fine_temperature_field, vector<vector<vector<double>>> fine_cure_field, vector<vector<double>> fine_mesh_loc)
{
	
	// Convert inputs
	PyObject* py_temperature_field = get_3D_list<vector<vector<vector<double>>>>(temperature_field);
	PyObject* py_cure_field = get_3D_list<vector<vector<vector<double>>>>(cure_field);
	PyObject* py_fine_temperature_field = get_3D_list<vector<vector<vector<double>>>>(fine_temperature_field);
	PyObject* py_fine_cure_field = get_3D_list<vector<vector<vector<double>>>>(fine_cure_field);
	PyObject* py_fine_mesh_loc = get_2D_list<vector<vector<double>>>(fine_mesh_loc);
	
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_field_history", "(O,O,O,O,O)", py_temperature_field, py_cure_field, py_fine_temperature_field, py_fine_cure_field, py_fine_mesh_loc);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_field_history function:\n");
		PyErr_Print();
		Py_DECREF(py_temperature_field);
		Py_DECREF(py_cure_field);
		Py_DECREF(py_fine_temperature_field);
		Py_DECREF(py_fine_cure_field);
		Py_DECREF(py_fine_mesh_loc);
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	Py_DECREF(py_temperature_field);
	Py_DECREF(py_cure_field);
	Py_DECREF(py_fine_temperature_field);
	Py_DECREF(py_fine_cure_field);
	Py_DECREF(py_fine_mesh_loc);
	return 0;
}

/**
* Stores front history to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param vector containing front location x and y indicies history
* @param vector containing front location fit history
* @param vector containing front speed field history
* @param vector containing front temperature history
* @param vector containing front shape parameter history
* @return 0 on success, 1 on failure
*/
int store_front_history(PyObject* save_render_plot, vector<vector<vector<double>>> front_curve, vector<vector<double>> front_fit, vector<double> front_velocity, vector<double> front_temperature, vector<double> front_shape_param)
{
	// Convert inputs
	PyObject* py_front_curve = get_3D_list<vector<vector<vector<double>>>>(front_curve);
	PyObject* py_front_fit = get_2D_list<vector<vector<double>>>(front_fit);
	PyObject* py_front_velocity = get_1D_list<vector<double>>(front_velocity);
	PyObject* py_front_temperature = get_1D_list<vector<double>>(front_temperature);
	PyObject* py_front_shape_param = get_1D_list<vector<double>>(front_shape_param);
	
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_front_history", "(O,O,O,O,O)", py_front_curve, py_front_fit, py_front_velocity, py_front_temperature, py_front_shape_param);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_front_history function:\n");
		PyErr_Print();
		Py_DECREF(py_front_curve);
		Py_DECREF(py_front_fit);
		Py_DECREF(py_front_velocity);
		Py_DECREF(py_front_temperature);
		Py_DECREF(py_front_shape_param);
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	Py_DECREF(py_front_curve);
	Py_DECREF(py_front_fit);
	Py_DECREF(py_front_velocity);
	Py_DECREF(py_front_temperature);
	Py_DECREF(py_front_shape_param);
	return 0;
}

/**
* Stores target, time, and best reward values to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param vector containing target velocity as a function of time
* @param vector containing time history
* @param vector containing reward history
* @return 0 on success, 1 on failure
*/
int store_target_and_time(PyObject* save_render_plot, vector<double> target, vector<double> time, vector<vector<double>> reward)
{
	// Convert inputs
	PyObject* py_target = get_1D_list<vector<double>>(target);
	PyObject* py_time = get_1D_list<vector<double>>(time);
	PyObject* py_reward = get_2D_list<vector<vector<double>>>(reward);
	
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_target_and_time", "(O,O,O)", py_target, py_time, py_reward);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_target_and_time function:\n");
		PyErr_Print();
		Py_DECREF(py_target);
		Py_DECREF(py_time);
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	Py_DECREF(py_target);
	Py_DECREF(py_time);
	return 0;
}

/**
* Stores top layer of mesh to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param x coordinates of top layer of mesh
* @param y coordinates of top layer of mesh
* @return 0 on success, 1 on failure
*/
int store_top_mesh(PyObject* save_render_plot, vector<vector<double>> mesh_x_z0, vector<vector<double>> mesh_y_z0)
{
	// Convert inputs
	PyObject* py_mesh_x_z0 = get_2D_list<vector<vector<double>>>(mesh_x_z0);
	PyObject* py_mesh_y_z0 = get_2D_list<vector<vector<double>>>(mesh_y_z0);
	
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_top_mesh", "(O,O)", py_mesh_x_z0, py_mesh_y_z0);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_top_mesh function:\n");
		PyErr_Print();
		Py_DECREF(py_mesh_x_z0);
		Py_DECREF(py_mesh_y_z0);
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	Py_DECREF(py_mesh_x_z0);
	Py_DECREF(py_mesh_y_z0);
	return 0;
}

/**
* Stores input parameters to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param peak irradiance (W/m^2) of input
* @param exponential constant used to calculate input field density
* @return 0 on success, 1 on failure
*/
int store_input_params(PyObject* save_render_plot, double max_input_mag, double exp_const)
{
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_input_params", "(d,d)", max_input_mag, exp_const);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_input_params function:\n");
		PyErr_Print();
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	return 0;

}

/**
* Stores simulation options  to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param whether front speed was the control target
* @param boolean flag that indicates whether the x and y actions were rates or positions
* @param String containing fds and train_agent config values
* @return 0 on success, 1 on failure
*/
int store_options(PyObject* save_render_plot, bool control_speed, string configs_string)
{
	// Convert inputs
	int int_control_speed = control_speed ? 1 : 0;
	const char* configs_c_str = configs_string.c_str();
	
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_options", "(i, s)", int_control_speed ,configs_c_str);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_options function:\n");
		PyErr_Print();
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	return 0;
}

/**
* Stores select monomer physical properties to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param Specific heat of monomer [J/Kg-K]
* @param Density of monomer [Kg/m^3]
* @param Adiabatic temperature of reaction of monomer given initial conditions [K]
* @return 0 on success, 1 on failure
*/
int store_monomer_properties(PyObject* save_render_plot, double specific_heat, double density, double adiabatic_rxn_temp)
{
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_monomer_properties", "(d,d,d)", specific_heat, density,adiabatic_rxn_temp);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_monomer_properties function:\n");
		PyErr_Print();
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	return 0;
}

/**
* Stores select simulation domain properties to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param volume of domain [m^3]
* @param wetted surface area of domain [m^2]
* @return 0 on success, 1 on failure
*/
int store_domain_properties(PyObject* save_render_plot, double volume, double surface_area)
{
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_domain_properties", "(d,d)", volume, surface_area);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_domain_properties function:\n");
		PyErr_Print();
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	return 0;	
}

/**
* Stores boundary conditions to the save_render_plot class
* @param pointer to the save_render_plot class in the PPO module
* @param Thin film coefficient of simulation domain [W/m^2-K]
* @param Ambient temperature [K]
* @param Initial temperature of simulation [K]
* @return 0 on success, 1 on failure
*/
int store_boundary_conditions(PyObject* save_render_plot, double heat_transfer_coeff, double ambient_temp, double initial_temperature)
{
	// Call function
	PyObject* result = PyObject_CallMethod(save_render_plot, "store_boundary_conditions", "(d,d,d)", heat_transfer_coeff, ambient_temp, initial_temperature);
	if (result==NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's store_boundary_conditions function:\n");
		PyErr_Print();
		return 1;
	}
	
	// Free memory
	Py_DECREF(result);
	return 0;
}


//******************************************************************** PYTHON API SAVE, PLOT, RENDER FUNCTIONS ********************************************************************//
/**
* Calls the save, plot, and render functions of the save_render_plot class in the PPO module, decrefs agent and save_render_plot
* @param pointer to the save_render_plot class in the PPO module
* @param Python pointer pointing at the trained agent
* @param Boolean flag that indicates whether to render the saved trajectory
* @return 0 on success, 1 on failure
*/
int save_agent_results(PyObject* save_render_plot, PyObject* agent, bool render)
{
	// Save
	if(PyObject_CallMethod(save_render_plot, "save", "O", agent) == NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's save function:\n");
		PyErr_Print();
		if (agent != NULL) { Py_DECREF(agent); }
		if (save_render_plot != NULL) { Py_DECREF(save_render_plot); }
		return 1;
	}
	
	// Plot
	if(PyObject_CallMethod(save_render_plot, "plot", "i", 1) == NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's plot function:\n");
		PyErr_Print();
		if (agent != NULL) { Py_DECREF(agent); }
		if (save_render_plot != NULL) { Py_DECREF(save_render_plot); }
		return 1;
	}
	
	// Render
	if (render)
	{
		if(PyObject_CallMethodObjArgs(save_render_plot, PyUnicode_DecodeFSDefault("render"), NULL) == NULL)
		{
			fprintf(stderr, "\nFailed to call Save_Plot_Render's render function:\n");
			PyErr_Print();
			if (agent != NULL) { Py_DECREF(agent); }
			if (save_render_plot != NULL) { Py_DECREF(save_render_plot); }
			return 1;
		}	
	}
	
	// Free memory
	Py_DECREF(agent);
	Py_DECREF(save_render_plot);
	return 0;
}

/**
* Calls the save, plot, and render functions of the save_render_plot class in the PPO module
* @param pointer to the save_render_plot class in the PPO module
* @param Boolean flag that indicates whether to render the saved trajectory
* @return 0 on success, 1 on failure
*/
int save_results(PyObject* save_render_plot, bool render)
{
	// Save
	if(PyObject_CallMethodObjArgs(save_render_plot, PyUnicode_DecodeFSDefault("save_without_agent"), NULL) == NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's save function:\n");
		PyErr_Print();
		if (save_render_plot != NULL) { Py_DECREF(save_render_plot); }
		return 1;
	}
	
	// Plot
	if(PyObject_CallMethod(save_render_plot, "plot", "i", 0) == NULL)
	{
		fprintf(stderr, "\nFailed to call Save_Plot_Render's plot function:\n");
		PyErr_Print();
		if (save_render_plot != NULL) { Py_DECREF(save_render_plot); }
		return 1;
	}
	
	// Render
	if (render)
	{
		if(PyObject_CallMethodObjArgs(save_render_plot, PyUnicode_DecodeFSDefault("render"), NULL) == NULL)
		{
			fprintf(stderr, "\nFailed to call Save_Plot_Render's render function:\n");
			PyErr_Print();
			if (save_render_plot != NULL) { Py_DECREF(save_render_plot); }
			return 1;
		}
	}
	
	// Free memory
	Py_DECREF(save_render_plot);
	return 0;
}